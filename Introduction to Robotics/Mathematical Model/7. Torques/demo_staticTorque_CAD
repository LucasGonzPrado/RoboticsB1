%% =============== ROBOT STATIC TORQUE AT WORK POSE =======================
% Computes the required joint torques to hold the robot at qf (work pose)
% under gravity + payload, using the same DH/MDH and SolidWorks parameters.
%
% Output: tau_static [N*m]
% ========================================================================

clear; clc; close all;

%% =================== USER SETTINGS ======================================
useMDH = true;           % true = Craig MDH, false = standard DH
gvec   = [0 0 -9.81];    % gravity direction in base frame

payload_mass   = 1.0;              % [kg] tool + payload
payload_offset = [0 0 0.069];      % [m] along tool z

%% =================== MDH PARAMETERS (geometry only) =====================
% Columns: [theta0   d       a       alpha    (dummy)]
% Last column is ignored here (all revolute). We keep 5 columns to
% resemble your other tables, but only 1..4 are used.
MDH = [ 0      0.0310   0        0;
        0      0        0        pi/2;
        0      0        0.1405   0;
        0      0        0.1940  -pi/2;
        0      0        0        pi/2;
        0      0        0        0 ];
n = size(MDH,1);

%% =================== q0 and qf =========================================
% q0 = configuration at which SolidWorks COMs were measured
q0 = [0; 2.1651; -2.1650; 0; 0; 0];

% Work pose (qf) – you overwrite q1 = 45° as requested
qf = [3.1416; 0.9766; -1.5708; 0; 0; 1.5708];
qf(1) = deg2rad(45);

%% =================== SolidWorks mass properties =========================
% Masses [g] from SolidWorks
m_g = [13000.; 11000.; 9000.; 3250.; 2250.; 1400.];

% COM positions in base frame [mm] at configuration q0
com_mm = [ 35.04   80.33   -0.40;
           65.96  200.93   14.70;
           33.04  274.71   -6.22;
          116.05  277.78   -5.00;
          176.84  279.90   -5.32;
          213.50  278.50   -5.62 ];

% Inertia tensors in base frame [g*mm^2] at q0
I_gmm2 = [ 1082330.28  1114029.01  2042404.18   947503.35   -12587.98   -12452.88;
            299297.11   162913.61   457462.86  -201868.63    -2620.96     1851.38;
             12712.72    41486.86    41318.67     1053.42       53.20     1458.06;
             30873.46   120823.85   106132.85     3342.90     -165.41     -304.28;
              9440.88    24502.93    24323.38      487.40       -4.83      -70.43;
             23692.47    20439.41    25088.16    -3720.73      -13.74     -147.12 ];

% Convert units: g -> kg, mm -> m, g*mm^2 -> kg*m^2
m        = m_g * 1e-3;
com_base = com_mm * 1e-3;
I_base   = zeros(3,3,n);
for i = 1:n
    Lxx = I_gmm2(i,1); Lyy = I_gmm2(i,2); Lzz = I_gmm2(i,3);
    Lxy = I_gmm2(i,4); Lyz = I_gmm2(i,5); Lxz = I_gmm2(i,6);

    I_mat_gmm2 = [ Lxx  Lxy  Lxz;
                   Lxy  Lyy  Lyz;
                   Lxz  Lyz  Lzz ];
    I_base(:,:,i) = I_mat_gmm2 * 1e-9;
end

%% ===== Convert COM + inertia from base frame to link frames at q0 =======
T0 = repmat(eye(4),1,1,n);
for i = 1:n
    T = eye(4);
    for k = 1:i
        theta0_k = MDH(k,1);
        d_k      = MDH(k,2);
        a_k      = MDH(k,3);
        alpha_k  = MDH(k,4);

        theta_k = theta0_k + q0(k);

        if useMDH
            A = mdhA(a_k, alpha_k, d_k, theta_k);
        else
            A = dhA(a_k, alpha_k, d_k, theta_k);
        end
        T = T * A;
    end
    T0(:,:,i) = T;
end

r_link = zeros(n,3);      % COM in each link frame
I_link = zeros(3,3,n);    % inertia in each link frame

for i = 1:n
    Ti = T0(:,:,i);
    Ri = Ti(1:3,1:3);
    pi = Ti(1:3,4);

    % COM in frame i: r_i = R_i^T (com_base - p_i)
    r_link(i,:) = (Ri' * (com_base(i,:)' - pi))';

    % inertia in frame i: I_i = R_i^T * I_base * R_i
    I_link(:,:,i) = Ri' * I_base(:,:,i) * Ri;
end

%% =================== Build SerialLink robot ============================
for i = 1:n
    L(i) = mkLink(MDH(i,:), useMDH);
    L(i).m = m(i);
    L(i).r = r_link(i,:);        % [rx ry rz] in link frame
    I = I_link(:,:,i);
    L(i).I = [I(1,1) I(2,2) I(3,3) I(1,2) I(2,3) I(1,3)];
end

robot = SerialLink(L, 'name', 'MyRobot');
robot.gravity = gvec;
robot.payload(payload_mass, payload_offset);

%% =================== Static torque at qf ================================
qd  = zeros(1,n);
qdd = zeros(1,n);

tau_static = robot.rne(qf', qd, qdd);  % [N*m]
disp('Static holding torque at work pose (qf):');
disp(tau_static.');

%% =================== Local helper functions ============================
function L = mkLink(row, useMDH)
    theta0 = row(1);
    d      = row(2);
    a      = row(3);
    alpha  = row(4);
    offset = theta0;   % we encode home angle in offset

    if useMDH
        L = RevoluteMDH('d', d, 'a', a, 'alpha', alpha, 'offset', offset);
    else
        L = Revolute('d', d, 'a', a, 'alpha', alpha, 'offset', offset);
    end
end

function A = dhA(a, alpha, d, theta)
    ct = cos(theta); st = sin(theta);
    ca = cos(alpha); sa = sin(alpha);

    A = [ ct   -st*ca   st*sa   a*ct;
          st    ct*ca  -ct*sa   a*st;
          0     sa      ca      d;
          0     0       0       1 ];
end

function A = mdhA(a, alpha, d, theta)
    ct = cos(theta); st = sin(theta);
    ca = cos(alpha); sa = sin(alpha);

    A = [ ct   -st    0     a;
          st*ca ct*ca -sa  -d*sa;
          st*sa ct*sa  ca   d*ca;
          0      0     0     1 ];
end
